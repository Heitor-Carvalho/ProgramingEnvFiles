#!/usr/bin/env python

import sys
import os
import argparse
import json
import subprocess
import glob

def run_command(command):
    print("Running command: {}".format(command))
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)
    while True:
        nextline = process.stdout.readline()
        if nextline == '' and process.poll() is not None:
            break
        sys.stdout.write(nextline)
        sys.stdout.flush()

def run_ans_command(command):
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)
    return process.stdout.readlines()

def get_currnet_toolchain():
    cmd_ans = run_ans_command("topbuild toolchain")
    toolchain_line = [cmd for cmd in cmd_ans if cmd[0] == ">"]
    return toolchain_line[0].strip()[2:]

def get_working_files(wr_path):
    working_files       = open(wr_path, 'r').readlines()
    valid_working_files = [wfile for wfile in working_files if wfile[0] != '#']
    return valid_working_files

def get_target_info(config_file):
    # Looking config file
    if os.path.exists(config_file) == True:
        try:
            json_file = open(config_file, 'r')
            target_info = json.load(json_file)
        except:
            print("Invalid json format")
            sys.exit(-1)
    else:
        print("File {} Not Found".format(config_file))
        sys.exit(-1)

    return target_info

def run_build(working_files, target):
    for working_file in working_files:
        if target == 'all':
            command = 'topbuild build {}'.format(working_file.strip())
        else:
            command = 'topbuild build {}/{}'.format(working_file.strip(), target.strip())
        run_command(command)

def run_forced_build(working_files, target):
    for working_file in working_files:
        if target == 'all':
            command = 'topbuild build -f {}'.format(working_file.strip())
        else:
            command = 'topbuild build -f {}/{}'.format(working_file.strip(), target.strip())
        run_command(command)

def find_so_files(search_path, target):
    shared_files = glob.glob(search_path + '/**/*so')
    for sh_file in shared_files:
        if sh_file.find(target) != -1:
            return sh_file

    # try in dist directory
    dist_search_path = search_path.rsplit('/', 1)[0] + '/dist'
    shared_files = glob.glob(dist_search_path + '/**/**/*so')
    for sh_file in shared_files:
        if sh_file.find(target) != -1:
            return sh_file
    return None

def find_bin_files(search_path, target):
    bin_files = glob.glob(search_path + '/**/*' + target)
    for bin_file in bin_files:
        if bin_file.find(target) != -1:
            return bin_file

    return None

def get_copy_command(copy_type, ssh_port, copy_file, target_path):
    if copy_type == "rsync":
        return 'rsync -zavP -e \'ssh -p {}\' {} {}'.format(ssh_port, copy_file, target_path)
    elif copy_type == "scp":
        return 'scp -P {} -r {} {}'.format(ssh_port, copy_file, target_path)
    else:
        print("Copy command not found")
        return None

# Handle build
def build(build_args):
    working_files = get_working_files(build_args.wr)
    if build_args.forced == False:
        run_build(working_files, build_args.target)
    else:
        run_forced_build(working_files, build_args.target)

# Handle install
def install(install_args):
    working_files = get_working_files(install_args.wr)

    target_info = get_target_info(install_args.config_file)

    sshpass_command = 'sshpass -p "{}"'.format(target_info['password'])

    for working_file in working_files:
        file_type = None
        base_search_path = working_file.strip() + "/build/" + target_info['toolchain']
        shared_file = find_so_files(base_search_path, install_args.target)
        # TODO improve this if logic
        if shared_file is None:
            bin_file = find_bin_files(base_search_path, install_args.target)
            if bin_file is None:
                print("No shared library or binary file founded for {}".format(working_file))
                continue
            else:
                copy_file = bin_file
                file_type = 'bin_file'
        else:
            copy_file = shared_file
            file_type = 'shared_file'

        if install_args.strip:
            project_path = target_info["project_path"]
            toolchain_path = target_info["toolchain_path"]
            strip_tool = target_info["strip_tool"]
            strip_command = project_path + toolchain_path + "/bin/" + strip_tool + " " + copy_file
            run_command(strip_command)

        if file_type == 'shared_file':
            target_path = '{}@{}:{}'.format(target_info['user'], target_info['ip'], target_info['shared_path'])
        elif file_type == 'bin_file':
            target_path = '{}@{}:{}'.format(target_info['user'], target_info['ip'], target_info['bin_path'])
        else:
            print("Non valid file_type found")
            sys.exit(-1)

        copy_command = get_copy_command(target_info['copy_command'], target_info['ssh_port'], copy_file, target_path)
        command = "{} {}".format(sshpass_command, copy_command)
        run_command(command)

# Handle installproj
def installproj(installproj_args):

    target_info = get_target_info(installproj_args.config_file)

    command = 'rm -rf {}/proj_install'.format(target_info['project_path'])
    run_command(command)
    command = 'mkdir {}/proj_install'.format(target_info['project_path'])
    run_command(command)
    command = 'topbuild install -d {}/proj_install'.format(target_info['project_path'])
    run_command(command)
    copy_file = '{}/proj_install/opt/'.format(target_info['project_path'])
    target_path = '{}@{}:{}'.format(target_info['user'], target_info['ip'], '/opt/')
    copy_command = get_copy_command(target_info['copy_command'], target_info['ssh_port'], copy_file, target_path)
    copy_command = 'sshpass -p "{}" '.format(target_info['password']) + copy_command
    run_command(copy_command)

# Handle clearall
def clearall(clearall_args):

    working_files = get_working_files(clearall_args.wr)
    for working_file in working_files:
        command = 'topbuild clean {}'.format(working_file.strip())
        run_command(command)

# Handle copy
def copyfile(copy_args):

    target_info = get_target_info(copy_args.config_file)

    target_path = '{}@{}:{}'.format(target_info['user'], target_info['ip'], copy_args.target_path)
    copy_command = get_copy_command(target_info['copy_command'], target_info['ssh_port'], copy_args.copyfile, target_path)
    sshpass_command = 'sshpass -p "{}"'.format(target_info['password'])
    command = "{} {}".format(sshpass_command, copy_command)
    run_command(command)

# Handle fixssh
def fixssh(fixssh_args):

    target_info = get_target_info(fixssh_args.config_file)
    sshpass_command = 'ssh-keyscan -p {} {} > $HOME/.ssh/known_hosts'.format(target_info['ssh_port'], target_info['ip'])
    run_command(sshpass_command)

# Handle creaprojfiles
def createprojfiles(createprojfiles_args):
    working_path = os.getcwd()
    toolchain = "/" + get_currnet_toolchain() + "/"
    workingpathconfig_templace = {\
      "ip":           "",\
      "ssh_port":     "",\
      "user":         "",\
      "password":     "",\
      "shared_path":  "",\
      "bin_path":     "",\
      "project_path": working_path,\
      "toolchain": toolchain,\
      "strip_tool": "",\
      "copy_command": "rsync"\
    }

    working_path_name = "workingpath.config"
    with open(working_path_name, 'w') as fd:
      json.dump(workingpathconfig_templace, fd, indent=4)

    working_repo_name = "workingrepos"
    command = "touch {}".format(working_path + '/' + working_repo_name)
    run_command(command)

# Handle fixconfigpath
def fixconfigpath(fixconfigpath_args):
    config_file = get_target_info(fixconfigpath_args.config_file)
    working_path = os.getcwd()
    toolchain = "/" + get_currnet_toolchain() + "/"
    config_file["project_path"] = working_path
    config_file["toolchain"] = toolchain

    working_path_name = "workingpath.config"
    with open(working_path_name, 'w') as fd:
      json.dump(config_file, fd, indent=4)


    padfolder = os.environ['HOME'] + "/.padtools"
    if os.path.exists(padfolder) == False:
        command = 'mkdir ' + padfolder
        run_command(command)

    symlink_cmd = "ln -s {}/workingrepos {}/workingrepos".format(working_path, padfolder)
    run_command(symlink_cmd)
    symlink_cmd = "ln -s {}/workingpath.config {}/workingpath.config".format(working_path, padfolder)
    run_command(symlink_cmd)


def main():
    # Main options
    working_cmds = argparse.ArgumentParser(description='Helper command build/install the working repos')

    # Sub options
    working_cmds_sub = working_cmds.add_subparsers()

    home_dir = os.getenv("HOME")
    workingpathconfig = home_dir + "/.padtools/workingpath.config"
    workingrepo = home_dir + "/.padtools/workingrepos"

    # Sub option build
    working_cmds_build = working_cmds_sub.add_parser('build', help='Build working repos')
    working_cmds_build.set_defaults(func=build)
    working_cmds_build.add_argument('--wr', type=str, required=False, default=workingrepo, dest='wr', help='working repos file')
    working_cmds_build.add_argument('--target', '-t', type=str, required=False, default='shared-debug', dest='target', help='Build target')
    working_cmds_build.add_argument('--forced', '-f', action='store_true', help='Force project to rebuild')

    # Sub option clearall
    working_cmds_clearall = working_cmds_sub.add_parser('clearall', help='Clear all copied file in the target')
    working_cmds_clearall.set_defaults(func=clearall)
    working_cmds_clearall.add_argument('--wr', type=str, required=False, default=workingrepo, dest='wr', help='working repos file')
    working_cmds_clearall.add_argument('--config_file', required=False, default=workingpathconfig, dest='config_file', help='Basic configuration need to install on target')

    # Sub option installproj
    working_cmds_installproj = working_cmds_sub.add_parser('installproj', help='Install all project files')
    working_cmds_installproj.set_defaults(func=installproj)
    working_cmds_installproj.add_argument('--config_file', required=False, default=workingpathconfig, dest='config_file', help='Basic configuration need to install on target')

    # Sub option install
    working_cmds_install = working_cmds_sub.add_parser('install', help='Install working repos')
    working_cmds_install.set_defaults(func=install)
    working_cmds_install.add_argument('--wr', type=str, required=False, default=workingrepo, dest='wr', help='working repos file')
    working_cmds_install.add_argument('--config_file', required=False, default=workingpathconfig, dest='config_file', help='Basic configuration need to install on target')
    working_cmds_install.add_argument('--strip', '-s', action='store_true', help='Strib file before install')
    working_cmds_install.add_argument('--target', '-t', type=str, required=False, default='debug', dest='target', help='Build target')

    # Sub option copyfile
    working_cmds_copy = working_cmds_sub.add_parser('copy', help='Copy a file to the board')
    working_cmds_copy.set_defaults(func=copyfile)
    working_cmds_copy.add_argument('--cp', type=str, required=True, dest='copyfile', help='file to be copied')
    working_cmds_copy.add_argument('--config_file', required=False, default=workingpathconfig, dest='config_file', help='Basic configuration need to install on target')
    working_cmds_copy.add_argument('--target_path', '-tp', required=False, default='/home/', dest='target_path', help='Path to copy the file in the target')

    # Sub option fixsshkey
    working_cmds_fixssh = working_cmds_sub.add_parser('fixssh', help='Fix sshkey when it changes')
    working_cmds_fixssh.set_defaults(func=fixssh)
    working_cmds_fixssh.add_argument('--config_file', required=False, default=workingpathconfig, dest='config_file', help='Basic configuration need to install on target')

    # Sub option create config file config
    working_cmds_createwkfile = working_cmds_sub.add_parser('create', help='Create need files to padtools to work')
    working_cmds_createwkfile.set_defaults(func=createprojfiles)

    # Sub option fix config path
    working_cmds_fixconfigpath = working_cmds_sub.add_parser('fixconfig', help='Fix config file to the currnet path')
    working_cmds_fixconfigpath.set_defaults(func=fixconfigpath)
    working_cmds_fixconfigpath.add_argument('--config_file', required=True, dest='config_file', help='Update path of current config file')

    args = working_cmds.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
