#!/usr/bin/env python

import sys
import os
import argparse
import json
import subprocess
import glob

def run_command(command):
    print("Running command: {}".format(command))
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)
    while True:
        nextline = process.stdout.readline()
        if nextline == '' and process.poll() is not None:
            break
        sys.stdout.write(nextline)
        sys.stdout.flush()

def get_working_files(wr_path):
    working_files       = open(wr_path, 'r').readlines()
    valid_working_files = [wfile for wfile in working_files if wfile[0] != '#']
    return valid_working_files

def run_build(working_files, target):
    for working_file in working_files:
        if target == 'all':
            command = 'topbuild build {}'.format(working_file.strip())
        else:
            command = 'topbuild build {}/{}'.format(working_file.strip(), target.strip())
        run_command(command)

def run_forced_build(working_files, target):
    for working_file in working_files:
        if target == 'all':
            command = 'topbuild build -f {}'.format(working_file.strip())
        else:
            command = 'topbuild build -f {}/{}'.format(working_file.strip(), target.strip())
        run_command(command)

def find_so_files(search_path, target):
    shared_files = glob.glob(search_path + '/**/*so')
    for sh_file in shared_files:
        if sh_file.find(target) != -1:
            return sh_file

    # try in dist directory
    dist_search_path = search_path.rsplit('/', 1)[0] + '/dist'
    shared_files = glob.glob(dist_search_path + '/**/**/*so')
    for sh_file in shared_files:
        if sh_file.find(target) != -1:
            return sh_file

    return None

def find_bin_files(search_path, target):
    bin_files = glob.glob(search_path + '/**/*' + target)
    for bin_file in bin_files:
        if bin_file.find(target) != -1:
            return bin_file

    return None

# Handle build
def build(build_args):
    working_files = get_working_files(build_args.wr)
    if build_args.forced == False:
        run_build(working_files, build_args.target)
    else:
        run_forced_build(working_files, build_args.target)

# Handle install
def install(install_args):
    working_files = get_working_files(install_args.wr)

    # Looking config file
    if os.path.exists(install_args.config_file) == True:
        try:
            json_file = open('workingpath.config', 'r')
            target_info = json.load(json_file)
        except:
            print("File {} Not Found".format(install_args.config_file))
            sys.exit(-1)
    else:
        sys.exit(-1)

    sshpass_command = 'sshpass -p "{}"'.format(target_info['password'])

    for working_file in working_files:
        file_type = None
        base_search_path = working_file.strip() + "/build/" + target_info['toolchain']
        shared_file = find_so_files(base_search_path, install_args.target)
        # TODO improve this if logic
        if shared_file is None:
            bin_file = find_bin_files(base_search_path, install_args.target)
            if bin_file is None:
                print("Non shared library or binary file founded for {}".format(working_file))
                sys.exit(-1)
            else:
                copy_file = bin_file
                file_type = 'bin_file'
        else:
            copy_file = shared_file
            file_type = 'shared_file'

        if install_args.strip:
            project_path = target_info["project_path"]
            toolchain_path = target_info["toolchain_path"]
            strip_tool = target_info["strip_tool"]
            strip_command = project_path + toolchain_path + "/bin/" + strip_tool + " " + copy_file
            run_command(strip_command)

        if file_type == 'shared_file':
            target_path = '{}@{}:{}'.format(target_info['user'], target_info['ip'], target_info['shared_path'])
        elif file_type == 'bin_file':
            target_path = '{}@{}:{}'.format(target_info['user'], target_info['ip'], target_info['bin_path'])
        else:
            print("Non valid file_type found")
            sys.exit(-1)

        rsync_command = 'rsync -avP -e \'ssh -p {}\' {} {}'.format(target_info['ssh_port'], copy_file, target_path)
        command = "{} {}".format(sshpass_command, rsync_command)
        run_command(command)

# Handle installproj
def installproj(installproj_args):

    # Looking config file
    if os.path.exists(installproj_args.config_file) == True:
        json_file = open('workingpath.config', 'r')
        target_info = json.load(json_file)
    else:
        print("File {} Not Found".format(installproj_args.config_file))
        sys.exit(-1)

    command = 'rm -rf {}/proj_install'.format(target_info['project_path'])
    run_command(command)
    command = 'mkdir {}/proj_install'.format(target_info['project_path'])
    run_command(command)
    command = 'topbuild install -d {}/proj_install'.format(target_info['project_path'])
    run_command(command)
    copy_file = '{}/proj_install/opt/'.format(target_info['project_path'])
    target_path = '{}@{}:{}'.format(target_info['user'], target_info['ip'], '/opt/')
    rsync_command = 'sshpass -p "{}" rsync -avP -e \'ssh -p {}\' {} {}'.format(target_info['password'], target_info['ssh_port'], copy_file, target_path)
    run_command(rsync_command)

# Handle clearall
def clearall(build_args):

    working_files = get_working_files(build_args.wr)
    for working_file in working_files:
        command = 'topbuild clean {}'.format(working_file.strip())
        run_command(command)

# Handle copy
def copyfile(copy_args):
    # Looking config file
    if os.path.exists(copy_args.config_file) == True:
        json_file = open('workingpath.config', 'r')
        target_info = json.load(json_file)
    else:
        print("File {} Not Found".format(copy_args.config_file))
        sys.exit(-1)

    target_path = '{}@{}:{}'.format(target_info['user'], target_info['ip'], '/home/')
    rsync_command = 'rsync -avP -e \'ssh -p {}\' {} {}'.format(target_info['ssh_port'], copy_args.copyfile, target_path)
    sshpass_command = 'sshpass -p "{}"'.format(target_info['password'])
    command = "{} {}".format(sshpass_command, rsync_command)
    run_command(command)

def main():
    # Main options
    working_cmds = argparse.ArgumentParser(description='Helper command build/install the working repos')

    # Sub options
    working_cmds_sub = working_cmds.add_subparsers()

    # Sub option build
    working_cmds_build = working_cmds_sub.add_parser('build', help='Build working repos')
    working_cmds_build.set_defaults(func=build)
    working_cmds_build.add_argument('--wr', type=str, required=False, default='workingrepos', dest='wr', help='working repos file')
    working_cmds_build.add_argument('--target', '-t', type=str, required=False, default='shared-debug', dest='target', help='Build target')
    working_cmds_build.add_argument('--forced', '-f', action='store_true', help='Force project to rebuild')

    # Sub option clearall
    working_cmds_clearall = working_cmds_sub.add_parser('clearall', help='Clear all copied file in the target')
    working_cmds_clearall.set_defaults(func=clearall)
    working_cmds_clearall.add_argument('--wr', type=str, required=False, default='workingrepos', dest='wr', help='working repos file')
    working_cmds_clearall.add_argument('--config_file', required=False, default='workingpath.config', dest='config_file', help='Basic configuration need to install on target')

    # Sub option installproj
    working_cmds_installproj = working_cmds_sub.add_parser('installproj', help='Install all project files')
    working_cmds_installproj.set_defaults(func=installproj)
    working_cmds_installproj.add_argument('--config_file', required=False, default='workingpath.config', dest='config_file', help='Basic configuration need to install on target')

    # Sub option install
    working_cmds_install = working_cmds_sub.add_parser('install', help='Install working repos')
    working_cmds_install.set_defaults(func=install)
    working_cmds_install.add_argument('--wr', type=str, required=False, default='workingrepos', dest='wr', help='working repos file')
    working_cmds_install.add_argument('--config_file', required=False, default='workingpath.config', dest='config_file', help='Basic configuration need to install on target')
    working_cmds_install.add_argument('--strip', '-s', action='store_true', help='Strib file before install')
    working_cmds_install.add_argument('--target', '-t', type=str, required=False, default='debug', dest='target', help='Build target')

    # Sub option copyfile
    working_cmds_copy = working_cmds_sub.add_parser('copy', help='Copy a file to the board')
    working_cmds_copy.set_defaults(func=copyfile)
    working_cmds_copy.add_argument('--cp', type=str, required=True, dest='copyfile', help='file to be copied')
    working_cmds_copy.add_argument('--config_file', required=False, default='workingpath.config', dest='config_file', help='Basic configuration need to install on target')

    args = working_cmds.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
